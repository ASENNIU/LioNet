# LioNet 协程库性能分析报告
第一版代码采取sylar的设计。

## 1. 测试环境

- CPU: 64 核 3737.89 MHz
- CPU 缓存:
  - L1 数据缓存: 32 KiB (x32)
  - L1 指令缓存: 32 KiB (x32)
  - L2 统一缓存: 512 KiB (x32)
  - L3 统一缓存: 32768 KiB (x8)
- 操作系统: Linux 6.2.0-34-generic
- 编译器: GCC 11.4.0
- 测试框架: Google Benchmark

注意: CPU 缩放已启用，可能会影响实时测量的准确性。

## 2. 测试方法

测试分为两个主要部分：协程创建 (BM_FiberCreation) 和协程切换 (BM_FiberSwitch)。每项测试都在不同的协程数量 (1000 和 3000) 和线程数 (1, 2, 4, 8, 16) 下进行。

- 协程创建测试: 测量创建指定数量协程所需的时间。
- 协程切换测试: 测量在指定数量的协程间进行 1000 次切换所需的时间。

## 3. 测试结果

### 3.1 协程创建性能


| 协程数 | 线程数 | 时间 (ns) | 创建速率 (items/s) | 平均创建时间 (ns/fiber) | 标准差 (ns) | 加速比 |
|--------|--------|-----------|-------------------|------------------------|------------|--------|
| 1000   | 1      | 3557298   | 281.112k          | 3557.30                | 14.49      | 1.00   |
| 1000   | 2      | 3557123   | 281.126k          | 3557.12                | 15.47      | 1.00   |
| 1000   | 4      | 3554345   | 281.346k          | 3554.35                | 14.50      | 1.00   |
| 1000   | 8      | 3560406   | 280.866k          | 3560.41                | 19.14      | 1.00   |
| 1000   | 16     | 3559788   | 280.915k          | 3559.79                | 15.48      | 1.00   |
| 3000   | 1      | 11227702  | 267.203k          | 3742.57                | 46.20      | 1.00   |
| 3000   | 2      | 11199540  | 267.869k          | 3733.18                | 75.94      | 1.00   |
| 3000   | 4      | 11197767  | 267.911k          | 3732.59                | 87.57      | 1.00   |
| 3000   | 8      | 11206335  | 267.707k          | 3735.45                | 45.83      | 1.00   |
| 3000   | 16     | 11199011  | 267.881k          | 3733.00                | 75.49      | 1.00   |

注：标准差和加速比是基于三次测试结果计算得出。

### 3.2 协程切换性能

| 协程数 | 线程数 | 时间 (ns) | 切换速率 (items/s) | 平均切换时间 (ns/switch) | 标准差 (ns) | 加速比 |
|--------|--------|-----------|-------------------|-------------------------|------------|--------|
| 1000   | 1      | 724088641 | 220.552M          | 724.09                  | 5.30       | 1.00   |
| 1000   | 2      | 624267007 | 431.309M          | 624.27                  | 18.51      | 1.16   |
| 1000   | 4      | 938064906 | 270.899M          | 938.06                  | 22.80      | 0.77   |
| 1000   | 8      | 1069489288| 241.442M          | 1069.49                 | 30.86      | 0.68   |
| 1000   | 16     | 1225384502| 199.437M          | 1225.38                 | 31.67      | 0.59   |
| 3000   | 1      | 2194733991| 220.315M          | 731.58                  | 12.53      | 1.00   |
| 1000   | 2      | 1993875993| 410.188M          | 664.63                  | 36.89      | 1.10   |
| 3000   | 4      | 2985946164| 259.838M          | 995.32                  | 50.85      | 0.73   |
| 3000   | 8      | 3503675863| 226.229M          | 1167.89                 | 98.09      | 0.63   |
| 3000   | 16     | 3754937239| 192.774M          | 1251.65                 | 98.25      | 0.58   |

注：标准差和加速比是基于三次测试结果计算得出。

## 4. 分析

### 4.1 协程创建性能

1. **一致性**: 创建性能在不同线程数下保持高度一致，标准差较小，表明创建过程是线程安全且高效的。
2. **可扩展性**: 从 1000 到 3000 个协程，平均创建时间仅增加约 5%，显示出良好的可扩展性。
3. **效率**: 平均每秒可创建约 267,000 到 281,000 个协程，性能表现优秀。
4. **线程影响**: 加速比接近 1.00，说明线程数对创建性能几乎没有影响。

### 4.2 协程切换性能

1. **线程敏感性**: 切换性能对线程数量高度敏感，2 线程配置在所有测试中表现最佳。
2. **性能峰值**: 2 线程配置下，1000 个协程可达到 431.309M 次/秒的切换率，加速比为 1.16。
3. **性能下降**: 随着线程数增加，切换性能和加速比显著下降，16 线程时加速比降至约 0.59。
4. **协程数量影响**: 3000 个协程的切换性能略低于 1000 个，但差异不大，表明良好的可扩展性。
5. **标准差**: 切换性能的标准差随线程数增加而增大，表明高线程数下性能的不稳定性增加。
## 5. 结论与建议

1. **创建性能**:
   - 结论: 协程创建性能优秀且稳定，不受线程数影响。
   - 建议: 当前实现已经非常高效，可以考虑进一步优化内存分配策略来提升大量协程创建的性能。

2. **切换性能**:
   - 结论: 2 线程配置提供最佳切换性能，高线程数下性能显著下降。
   - 建议: 
     a. 重点优化 4 线程及以上配置的切换性能。
     b. 研究 2 线程配置的优势，将其特性应用到其他线程配置中。
     c. 考虑实现自适应线程池大小，根据负载自动调整到最佳线程数。

3. **整体性能**:
   - 结论: 库在低线程数下表现出色，但在高并发环境中可能面临挑战。
   - 建议: 针对高线程数场景进行专门的优化，可能需要重新设计调度算法或引入更高效的同步机制。

4. **使用指南**:
   - 对于一般应用，推荐使用 2-4 线程配置以获得最佳性能。
   - 对于需要大量协程的应用，当前实现已经能够很好地支持，无需特别优化创建过程。
   - 在高并发环境中使用时，建议进行实际负载下的性能测试，并可能需要自定义线程数。

5. **未来优化方向**:
   - 实现协程工作窃取算法，提高多线程下的负载均衡。
   - 优化协程上下文切换的开销，特别是在高线程数环境下。
   - 重构调度器，减少锁竞争，提高并发效率。
   - 提供更细粒度的性能监控和调优选项，使用户能够根据具体应用场景优化性能。

6. **性能监控**:
   - 建议: 实现更细粒度的性能监控机制，特别是在多线程环境下，以便及时发现和解决性能瓶颈。
   - 行动: 添加详细的性能计数器和日志记录，用于跟踪协程的生命周期和切换频率。

7. **内存优化**:
   - 建议: 考虑实现协程栈池或使用更高效的内存分配策略，以进一步提高创建性能和减少内存碎片。
   - 行动: 分析当前内存使用模式，实现自定义内存分配器，专门针对协程栈的特点进行优化。

## 6. 后续工作

1. 进行更多样化的负载测试，模拟真实应用场景。
2. 对比其他知名协程库的性能，确定竞争优势和改进空间。
3. 进行内存使用分析，确保在高负载下内存效率。
4. 考虑添加异步 I/O 操作的性能测试，评估在 I/O 密集型应用中的表现。
5. 进行长时间运行测试，评估在持续高负载下的性能稳定性和内存使用情况。
6. 实现更多的性能指标收集点，以便进行更精细的性能分析和优化。

